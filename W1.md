# 每周总结

## week 1

### 行内元素

- 不会独占一行，一行可以存在多个行内元素
- 行高是行内元素的容器，决定其占位是否。
- 存在基线，每个元素都在其基线上，一行中每个元素基线的位置默认为行高最高的元素(即基准元素，也等于行框)的基线。vertical-align用来设置垂直位置，middle为行内所有中线对齐。
- 行内块元素也遵循基线对齐，行内块元素的基线为元素里面最后一行的基线。若里面没有元素则为其底线。

### float问题

- float会脱离所在父元素内的文档流(故不会离开父元素，也不会被父元素计算空间)
- float漂浮后变为没有基线的行内块元素
- float元素遇到同类float的元素或者定位元素时会停止漂浮（position）
- 父元素可以通过设置overflow为hidden强制计算float元素空间来防止塌陷，也可通过其最后子元素clear属性保留高度。

## week 2

### height-top

- offsetTop为元素top距离祖先元素的距离，若计算绝对到顶端的距离可以使用scollY+obj.getBoundingClientRect.Y(元素到窗口的高度)
- offsetHeight为元素高度包括padding，也可直接用height
- innerHeight为 窗口的高度

### 关键渲染路径

- style>layout>paint>composite
- 应用中的元素样式>这些元素生成形状和位置——布局>每个元素填充像素>绘制这些图层
- 故应该尽量用transform这样的不改变布局的属性；

### =100%？？

- 最上级的100%为是视窗大小的100%
- 绝对定位的100%包括border大小，其他则只包括内容。（起始位置都从父元素的content左上角开始

### 从头开始debounce

 ```js
function debounce(func, wait = 20, immediate = true) {
    var timeout;
    return function() {
        var context = this,
            args = arguments;
        var later = function() {
            timeout = null;
            if (!immediate) func.apply(context, args);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
    };
}
window.addEventListener("scroll", debounce(func))
 ```

- Q1：元素事件处理器所绑定的handle到底是什么？  
  A：handle = debounce(func),每次事件触发将执行的是 debounce的return ，即function。

- Q2：如何每次都能取到timeout?  
  A: 通过闭包，每次调用function时，遇到timeout标识符若本函数内词法环境中没有，将根据该函数的[[environment]](函数自身注册时的词法环境)中寻找(作用域链)，词法环境在函数创建时生成。 debounce作为声明，在全局中处理代码之前就应经解析创建注册。
  ps:js中所有的标识符寻找都通过作用域链，即取决于变量函数写在哪个作用域内。如下：

  ```javascript
        var a = function() {
        console.log(time)
    }

    function debounce1() {
        var time = 1
        a() //not defined
        return function() {
            time = time + 1;
            console.log(time); //2
            a() //not defined

        }
    }
    debounce1()()
  ```

- Q3: timeout=seTtimeout() ，赋的是什么值？  
  A: 赋值的是计时器`ID`，存在于浏览器中的全局变量， 每执行一次`setTimeout`都会+1，代表该计时器的序号。`clearTimeout`将取消计时器，包括其中的回调函数，但不会回收其`ID`。

- Q4: 为什么要赋值this？  
  A:因为setTimeout为全局函数，是浏览器所处理，无论在哪里执行this都是全局。

- Q5: immediate是什么？  
  A:immediate用来决定是否立即执行，即决定事件通过回调来执行还是通过判断timeout来立即执行。当immediate为true则是判断timeout,故第一下就能立即执行，当为false时需成功完成等待事件才能回调。
  
### 两种数据类型

- 基本数据类型
- - 包括，string,null,undefine,boolean,number,
- - 存储内容，变量名与数据本身
- - 存储位置，栈内存

- 引用数据类型
- - 包括，function,array,object
- - 存储内容：变量名与属性的指针(地址)
- - 属性指针在栈内存，指针指向的内容在堆内存

- PS: 栈与堆

 >栈内存，有序存储，容量小但分配效率高，易于回收是一种向低地址扩展的数据结构，并且是连续的存储空间，所以栈顶和栈的最大容量是固定的  
![栈与堆](https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3785498651,2265829815&fm=26&gp=0.jpg)  
![栈与堆](https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=6185001,4201650577&fm=26&gp=0.jpg)  
堆，是一种向高地址扩展的数据结构，并且是不连续的，因为系统采用的是链表的方式存放空闲存储块，当然是不连续的，链表的遍历方向是由低向高的，所以堆能够申请的空间的大小其实等同于整个系统的虚拟内存，只要还有内存空间，那么堆就能够不受限制的申请空间，这种方式比较灵活，申请空间也较大。

### js的隐式转换

- 一元运算符  通过+、-字符串将转化为数字类型

```js
var sNum = "20";
alert(typeof sNum); //输出 "string"
var iNum = -sNum;
alert(iNum);        //输出 "-20"
alert(typeof iNum); //输出 "number"
```

- 加法计算
若存在字符串将默认将其他元素转换为字符串进行拼接

```js
var result = 5 + 5; //两个数字
alert(result);      //输出 "10"
var result2 = 5 + "5";  //一个数字和一个字符串
alert(result);      //输出 "55"
```

## week 3

### array map set

- array  
- - 基本数组类型，创建方式2种：`[]`和`new Array()`,故将继承数组类的属性与方法
- - 常用方法：  
`.forEach(callback)`遍历回调;  
`.every(ninja => "name" in ninja)`遍历所有判断是否都有"name"接受回调Boolean值，若全部为`ture`则返回`ture`;  
`.some(ninja => "name" in ninja)`,遍历直至一个`ture`就返回;  
`ninjas.find(ninja =>  ninja.weapon === "wakizashi"）`使用find方法查找满足回调函数中指定条件的第1个元素，否则为undefined  
`.indexOf(value)`和`.findIndex(ninja =>ninja =="yoshi")`都返回满足的元素的索引;  
`.sort(num1,num2 => num1>num2?return 1;return -1)`,通过回调比较相邻两个数对其排序,若为1则交换位置.

- map
- - 字典数组类型,创建方式:`new Map([a,...])`
- - 特点:纯粹的字典映射,不继承普通对象的方法,比如`constructor`,同样也去除了`key`必须是字符串的限制
- - 常用方法:  
`map.set(ninja1,{name:"yoshi"})`,设置映射,map.`get(ninja1)`.name =='yoshi'  
`for of`对其中每个元素进行遍历,返回每个元素本身,包括key和value.`for in`则只返回key  
`.has(key)`通过对key进行hash运算后散射得到其index值,故能直接通过key进行哈希散射后匹配`map[hash(key)]`,所以时间复杂度为O(1),可利用其进行判断去重.

- set
- -唯一数组类型,创建方式:`new Set([a,...])`
- -特点:成员的值唯一,构建时和map一样通过hash运算散射索引.
